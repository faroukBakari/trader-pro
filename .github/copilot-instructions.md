Purpose
This file contains step-by-step instructions and examples to bootstrap a small FastAPI API server with a single healthcheck endpoint using Test Driven Development. It covers project layout, virtual environment isolation, dev dependencies, TDD workflow with pytest, OpenAPI client and docs generation, git initialization, and a GitHub Actions workflow that runs tests on push.

Quick overview
- Build with FastAPI and Uvicorn.
- Use TDD: write pytest tests first, implement the feature, run tests.
- Isolate environment with either Python venv + pip or Poetry.
- Autogenerate client from OpenAPI spec and host autogenerated docs.
- CI runs pytest and linters on push using GitHub Actions.
- Enforce code quality with pre-commit hooks and standard formatters.

Recommended project layout
my-api/
├─ .github/
│  └─ workflows/
│     └─ ci.yml
├─ src/
│  └─ my_api/
│     ├─ __init__.py
│     ├─ main.py
│     └─ api/
│        └─ health.py
├─ tests/
│  └─ test_health.py
├─ pyproject.toml or requirements-dev.txt
├─ setup.cfg or tox.ini (optional)
├─ .gitignore
└─ README.md



Environment isolation and dependency management
Choose one of two approaches.
Option A Use Python venv and pip
- Create project directory and venv:
python -m venv .venv
source .venv/bin/activate
- Upgrade pip and install dev deps:
pip install --upgrade pip setuptools wheel
pip install fastapi uvicorn pytest pytest-asyncio httpx "openapi-python-client" black isort flake8 mypy pre-commit
- Freeze pinned dev dependencies for reproducibility:
pip freeze > requirements-dev.txt


Option B Use Poetry (recommended for reproducible installs)
- Install Poetry and initialize:
curl -sSL https://install.python-poetry.org | python -
poetry new my-api --src
cd my-api
poetry env use python
poetry add fastapi uvicorn
poetry add --dev pytest pytest-asyncio httpx openapi-python-client black isort flake8 mypy pre-commit
- Use poetry run to execute commands inside the virtualenv:
poetry run pytest



Dev dependencies and best practices
- Formatters: black, isort
- Linters and type checking: flake8, mypy
- Tests: pytest, pytest-asyncio, httpx (async test client)
- Client generator: openapi-python-client or openapi-generator-cli
- Pre-commit hooks: configure pre-commit to run black/isort/flake8/mypy on commit
- Keep dev dependencies separate from runtime dependencies in pyproject or requirements-dev.txt
- Pin versions in a lock file (poetry.lock or requirements-dev.txt)

TDD workflow rules
- Write a failing test for the feature in tests/ (start with the smallest behavior).
- Run pytest and confirm the test fails.
- Implement minimal code to make the test pass.
- Run pytest until all tests pass.
- Refactor if needed while keeping tests green.
- Commit only passing code and updated tests.

Example healthcheck TDD cycle
Create test first at tests/test_health.py:
import pytest
from httpx import AsyncClient
from my_api.main import app

@pytest.mark.asyncio
async def test_healthcheck_returns_200_and_payload():
    async with AsyncClient(app=app, base_url="http://test") as ac:
        r = await ac.get("/health")
    assert r.status_code == 200
    assert r.json() == {"status": "ok"}


Run tests (they will fail because we have no implementation):
pytest -q


Implement minimal FastAPI app to satisfy the test at src/my_api/main.py:
from fastapi import FastAPI
from .api.health import router as health_router

app = FastAPI(title="My API")

app.include_router(health_router)


Create health router at src/my_api/api/health.py:
from fastapi import APIRouter
from fastapi.responses import JSONResponse

router = APIRouter()

@router.get("/health", summary="Healthcheck", tags=["health"])
async def healthcheck():
    return JSONResponse({"status": "ok"})


Run tests again:
pytest -q


All tests should pass.

OpenAPI client generation and autogenerated docs
- FastAPI exposes OpenAPI at /openapi.json and interactive docs at /docs and /redoc by default. Use those for initial inspection.
- To autogenerate a typed Python client from the OpenAPI spec use openapi-python-client:
# Fetch openapi.json into openapi.json
curl -sSL http://127.0.0.1:8000/openapi.json -o openapi.json
# Generate client
openapi-python-client generate --path openapi.json --output ./clients/my_api_client
- Alternatively use openapi-generator-cli for other languages:
openapi-generator-cli generate -i openapi.json -g python -o ./clients/my_api_client
- Add generation step to a small script or Makefile target:
gen-client:
    curl -sSL http://127.0.0.1:8000/openapi.json -o openapi.json
    openapi-python-client generate --path openapi.json --output ./clients/my_api_client



Autogenerating documentation for the project
- Use FastAPI's built-in docs for runtime API documentation on /docs and /redoc.
- For static project docs, consider MkDocs with mkdocstrings or Sphinx:
- Use mkdocs for markdown docs and publish on GitHub Pages.
- Include an automated job that builds docs from the running server's OpenAPI or the source docstrings.
- Example Makefile target to export HTML docs using Redoc CLI:
export-openapi:
    curl -sSL http://127.0.0.1:8000/openapi.json -o openapi.json

redoc-html:
    npx redoc-cli bundle openapi.json -o docs/openapi.html



Git initialization and repository hygiene
- Initialize git, add .gitignore, and make first commit:
git init
echo ".venv/" > .gitignore
echo "__pycache__/" >> .gitignore
echo ".pytest_cache/" >> .gitignore
echo "clients/" >> .gitignore
git add .
git commit -m "chore: initial project layout and tests"
- Keep generated clients and virtualenv out of repo; commit generator config (openapi.json or generator config) instead if desired.

Pre-commit configuration (example)
Create .pre-commit-config.yaml:
repos:
- repo: https

Instructions for frontend telemetry implementation:

Goal
Refactor telemetry instructions for a simpler, practical telemetry surface: implement a centralized TelemetryLogger class and TelemetryError class for the whole Vue frontend. No span or tracing implementations yet. Add a console wrapper and an unhandled-error wrapper, each controlled by environment variables for activation and deactivation.

Scope
- Vue 3 Composition API codebase.
- Files to add or modify: src/lib/telemetry/TelemetryLogger.ts, src/lib/telemetry/TelemetryError.ts, src/lib/telemetry/consoleWrapper.ts, src/lib/telemetry/unhandledErrorWrapper.ts, src/main.ts, src/lib/telemetry/README.md, .github/workflows/telemetry-validate.yml tests/telemetry/*.
- Behavior limited to structured logging and error records; telemetry export plumbing and spans are out of scope.

Requirements
- TelemetryLogger class must:
- Provide methods: debug, info, warn, error.
- Normalize log payloads to a JSON structure: timestamp, level, message, loggerName, route, component, userHash, metadata.
- Expose a configurable sink interface so logs can be forwarded to console, network endpoint, or a future OTLP exporter.
- Apply field-level redaction via a configurable redaction callback.
- Respect env var TELEMETRY_LOGGING_ENABLED to enable or disable sending to the sink while still optionally writing to console.
- TelemetryError class must:
- Wrap Error objects into a structured payload: name, message, stack, component, propsSnapshot, route, breadcrumbs, userHash, occurredAt.
- Provide a static factory TelemetryError.from(error, context) and instance method toLogPayload() returning the normalized payload.
- Provide a convenience method TelemetryError.report(logger) that calls logger.error with the payload.
- Console wrapper must:
- Replace direct console calls by exposing the same API: debug, log, info, warn, error.
- Be controlled by TELEMETRY_CONSOLE_ENABLED env var. When disabled, no console output should happen from the wrapper.
- When enabled, forward messages through TelemetryLogger.debug/info/warn/error and also call the native console when TELEMETRY_CONSOLE_NATIVE_FALLBACK=true.
- Unhandled error wrapper must:
- Install handlers for Vue global errorHandler, window.onerror, and unhandledrejection when TELEMETRY_UNHANDLED_ERRORS_ENABLED=true.
- Convert captured errors to TelemetryError instances and call TelemetryError.report using the TelemetryLogger sink.
- Provide an uninstall() function for tests and local dev.
- Configuration must be environment driven:
- TELEMETRY_LOGGING_ENABLED truefalse
- TELEMETRY_CONSOLE_ENABLED truefalse
- TELEMETRY_CONSOLE_NATIVE_FALLBACK truefalse
- TELEMETRY_UNHANDLED_ERRORS_ENABLED truefalse
- TELEMETRY_REDaction_MODE denylisthashnone (string key for the redaction strategy)
- Testing must include:
- Unit tests for TelemetryLogger serialization, redaction, and sink calls.
- Unit tests for TelemetryError.from and toLogPayload structure.
- Integration tests that simulate Vue errorHandler and window unhandledrejection and assert TelemetryLogger.error was called with normalized payload.
- Tests must use a mock sink and should cleanly uninstall unhandled wrappers.
- Documentation must include usage, env vars, how to disable in local dev, and examples.

Concrete tasks
- Create src/lib/telemetry/Sink.ts defining the sink interface and a simple HttpSink implementation placeholder that POSTs JSON to TELEMETRY_SINK_URL when TELEMETRY_LOGGING_ENABLED is true.
- Implement src/lib/telemetry/TelemetryLogger.ts:
- Constructor accepts loggerName and options { sink, redactCallback, consoleFallback }.
- Methods debug/info/warn/error build normalized payload and call sink.send(payload) when enabled.
- When console fallback enabled call native console methods.
- Implement src/lib/telemetry/TelemetryError.ts:
- Static from(error, context) builds TelemetryError with component, propsSnapshot, route, breadcrumbs captured from context.
- toLogPayload returns the normalized object ready for TelemetryLogger.
- report(logger) calls logger.error with payload.
- Implement src/lib/telemetry/consoleWrapper.ts:
- Export the same API as global console with activation via TELEMETRY_CONSOLE_ENABLED.
- Use TelemetryLogger internally to record messages when enabled.
- Respect TELEMETRY_CONSOLE_NATIVE_FALLBACK to call native console methods when enabled.
- Implement src/lib/telemetry/unhandledErrorWrapper.ts:
- Export install(app, router?, options?) which wires Vue global errorHandler, window.onerror, and window.onunhandledrejection when TELEMETRY_UNHANDLED_ERRORS_ENABLED.
- Convert errors to TelemetryError and call TelemetryError.report using a TelemetryLogger instance.
- Export uninstall() to remove handlers.
- Wire into src/main.ts:
- Initialize a default TelemetryLogger instance with name app-root and configured sink and redact callback.
- Import and call install from unhandledErrorWrapper if TELEMETRY_UNHANDLED_ERRORS_ENABLED=true.
- Replace any direct console usage with consoleWrapper import where appropriate.
- Add tests under tests/telemetry:
- telemetry.logger.spec.ts unit tests for payload and sink interactions.
- telemetry.error.spec.ts unit tests for TelemetryError transformations.
- telemetry.unhandled.spec.ts integration tests verifying handlers report to mock sink.
- Add .github/workflows/telemetry-validate.yml:
- Job runs tests and a simple script that asserts TELEMETRY_LOGGING_ENABLED is false in default CI unless explicitly enabled by a secret or matrix entry.
- Add src/lib/telemetry/README.md describing configuration, disabling in dev, and example usage.

Deliverables
- src/lib/telemetry/Sink.ts
- src/lib/telemetry/TelemetryLogger.ts
- src/lib/telemetry/TelemetryError.ts
- src/lib/telemetry/consoleWrapper.ts
- src/lib/telemetry/unhandledErrorWrapper.ts
- src/lib/telemetry/README.md
- tests/telemetry/telemetry.logger.spec.ts
- tests/telemetry/telemetry.error.spec.ts
- tests/telemetry/telemetry.unhandled.spec.ts
- .github/workflows/telemetry-validate.yml
- Example patch instructions for src/main.ts showing how to initialize and install the unhandled wrapper

Minimal example implementations
- TelemetryLogger example
// src/lib/telemetry/TelemetryLogger.ts
import type { Sink } from './Sink';

export type RedactCallback = (payload: Record<string, any>) => Record<string, any>;

export class TelemetryLogger {
  private name: string;
  private sink?: Sink;
  private redact: RedactCallback;
  private enabled: boolean;
  private consoleFallback: boolean;

  constructor(name = 'app', opts: { sink?: Sink; redact?: RedactCallback; enabled?: boolean; consoleFallback?: boolean } = {}) {
    this.name = name;
    this.sink = opts.sink;
    this.redact = opts.redact ?? (p => p);
    this.enabled = opts.enabled ?? (process.env.TELEMETRY_LOGGING_ENABLED === 'true');
    this.consoleFallback = opts.consoleFallback ?? (process.env.TELEMETRY_CONSOLE_NATIVE_FALLBACK === 'true');
  }

  private build(level: string, message: string, meta?: Record<string, any>) {
    const base = {
      timestamp: new Date().toISOString(),
      level,
      message,
      loggerName: this.name,
      metadata: meta || {},
      env: process.env.NODE_ENV || 'development',
    };
    return this.redact(base);
  }

  private async send(payload: Record<string, any>) {
    if (!this.enabled) return;
    if (this.sink) await this.sink.send(payload);
    if (this.consoleFallback && typeof console !== 'undefined') {
      const fn = (console as any)[payload.level] ?? console.log;
      try { fn(JSON.stringify(payload)); } catch { /* noop */ }
    }
  }

  debug(message: string, meta?: Record<string, any>) { void this.send(this.build('debug', message, meta)); }
  info(message: string, meta?: Record<string, any>) { void this.send(this.build('info', message, meta)); }
  warn(message: string, meta?: Record<string, any>) { void this.send(this.build('warn', message, meta)); }
  error(message: string, meta?: Record<string, any>) { void this.send(this.build('error', message, meta)); }
}

- TelemetryError example
// src/lib/telemetry/TelemetryError.ts
import { TelemetryLogger } from './TelemetryLogger';

export type ErrorContext = {
  component?: string;
  propsSnapshot?: Record<string, any>;
  route?: { name?: string; path?: string };
  breadcrumbs?: Array<Record<string, any>>;
  userHash?: string;
};

export class TelemetryError {
  name: string;
  message: string;
  stack?: string;
  context: ErrorContext;
  occurredAt: string;

  constructor(name: string, message: string, stack?: string, context: ErrorContext = {}) {
    this.name = name;
    this.message = message;
    this.stack = stack;
    this.context = context;
    this.occurredAt = new Date().toISOString();
  }

  static from(err: unknown, context: ErrorContext = {}) {
    if (err instanceof Error) {
      return new TelemetryError(err.name, err.message, err.stack, context);
    }
    return new TelemetryError('NonError', String(err), undefined, context);
  }

  toLogPayload() {
    return {
      name: this.name,
      message: this.message,
      stack: this.stack,
      occurredAt: this.occurredAt,
      ...this.context,
    };
  }

  report(logger: TelemetryLogger) {
    logger.error(this.message, this.toLogPayload());
  }
}

- Console wrapper example
// src/lib/telemetry/consoleWrapper.ts
import { TelemetryLogger } from './TelemetryLogger';
const enabled = process.env.TELEMETRY_CONSOLE_ENABLED === 'true';
const nativeFallback = process.env.TELEMETRY_CONSOLE_NATIVE_FALLBACK === 'true';
const logger = new TelemetryLogger('console-wrapper', { enabled: true, consoleFallback: nativeFallback });

export const consoleWrapper = {
  debug: (...args: any[]) => { if (!enabled) return; logger.debug(String(args[0] ?? ''), { args }); if (nativeFallback) console.debug(...args); },
  log: (...args: any[]) => { if (!enabled) return; logger.info(String(args[0] ?? ''), { args }); if (nativeFallback) console.log(...args); },
  info: (...args: any[]) => { if (!enabled) return; logger.info(String(args[0] ?? ''), { args }); if (nativeFallback) console.info(...args); },
  warn: (...args: any[]) => { if (!enabled) return; logger.warn(String(args[0] ?? ''), { args }); if (nativeFallback) console.warn(...args); },
  error: (...args: any[]) => { if (!enabled) return; logger.error(String(args[0] ?? ''), { args }); if (nativeFallback) console.error(...args); },
};

- Unhandled error wrapper example
// src/lib/telemetry/unhandledErrorWrapper.ts
import type { App } from 'vue';
import { TelemetryError } from './TelemetryError';
import { TelemetryLogger } from './TelemetryLogger';

let installed = false;
let originalHandlers: { onerror?: any; onrejection?: any } = {};
const logger = new TelemetryLogger('unhandled-error', { enabled: true });

export function install(app?: App, router?: any) {
  if (installed) return;
  const enabled = process.env.TELEMETRY_UNHANDLED_ERRORS_ENABLED === 'true';
  if (!enabled) return;
  // Vue handler
  if (app) {
    app.config.errorHandler = (err: unknown, vm: any, info: string) => {
      const ctx = { component: vm?.$options?.name, propsSnapshot: vm?.$props, route: router?.currentRoute?.value };
      const t = TelemetryError.from(err, { ...ctx, breadcrumbs: [{ info }] });
      t.report(logger);
    };
  }
  // window handlers
  originalHandlers.onerror = window.onerror;
  originalHandlers.onrejection = window.onunhandledrejection;
  window.onerror = function (msg, url, line, col, error) {
    const t = TelemetryError.from(error ?? msg, { breadcrumbs: [{ url, line, col }] });
    t.report(logger);
    if (originalHandlers.onerror) return originalHandlers.onerror.apply(this, arguments as any);
  };
  window.onunhandledrejection = function (ev) {
    const t = TelemetryError.from(ev.reason ?? ev, {});
    t.report(logger);
    if (originalHandlers.onrejection) return originalHandlers.onrejection.apply(this, arguments as any);
  };
  installed = true;
}

export function uninstall() {
  if (!installed) return;
  window.onerror = originalHandlers.onerror;
  window.onunhandledrejection = originalHandlers.onrejection;
  installed = false;
}


Usage example to wire in main.ts
// src/main.ts snippet
import { createApp } from 'vue';
import App from './App.vue';
import router from './router';
import { install as installUnhandled } from './lib/telemetry/unhandledErrorWrapper';
import { consoleWrapper } from './lib/telemetry/consoleWrapper';

const app = createApp(App);
app.use(router);
installUnhandled(app, router);

// Optionally replace global console usage via app.config.globalProperties if desired
app.config.globalProperties.$console = consoleWrapper;

app.mount('#app');


Notes for reviewers
- Redaction callback must be implemented to match product PII rules before enabling TELEMETRY_LOGGING_ENABLED in production.
- TELEMETRY_LOGGING_ENABLED should default to false in CI and local dev.
- Sink.Http implementation must enforce batching, backoff, and size limits when added.



Resouces to explore for documentation: 
OTel Documentation
https://opentelemetry.io/docs/

Language APIs and SDKs Doc
https://opentelemetry.io/docs/languages/js/

Copilot instructions for working with TradingView Charting Library

Overview
- Purpose: Help a developer quickly run, integrate, extend, and debug the TradingView Charting Library located at frontend/public/charting_library in the project.
- Primary resources: official docs, tutorials, tutorial code, and examples — links provided below. Use your MCP web-search server to locate additional pages, follow internal links, and retrieve sample code as needed.

Direct links to use
- TradingView GitHub organization: https://github.com/tradingview
- Charting Library Tutorials: https://www.tradingview.com/charting-library-docs/latest/tutorials/
- Charting Library tutorial code repo: https://github.com/tradingview/charting-library-tutorial
- Charting Library examples repo: https://github.com/tradingview/charting-library-examples
- Getting started documentation: https://www.tradingview.com/charting-library-docs/latest/getting_started/
- Full API reference: https://www.tradingview.com/charting-library-docs/latest/api/

Quick start checklist
- Confirm files
- Verify the Charting Library files exist at frontend/public/charting_library and that the release matches the examples you plan to use.
- Run a tutorial/example locally
- Clone the tutorial or examples repo, align its charting_library path with frontend/public/charting_library, then serve static files (for example using a simple static server) and open the demo index.
- Implement a minimal Datafeed
- Implement required Datafeed methods: searchSymbols, resolveSymbol, getBars, subscribeBars, unsubscribeBars. Use the tutorial repo as a working reference.
- Verify SymbolInfo and time settings
- Ensure SymbolInfo shapes, timezone settings, and resolutions match your data source to avoid missing bars or misaligned timestamps.
- Add streaming and subscription logic
- Wire streaming ticks into subscribeBars; handle resubscriptions and edge cases such as session boundaries and market holidays.
- Integrate Broker features only if needed
- If using trading features, follow Broker module patterns in tutorials for order creation, account flow, and host callbacks.

Recommended dev workflow
- Use the matching example from charting-library-examples for your framework (React, Vue, Next.js, Svelte, plain HTML, etc.) and adapt container and lifecycle handling.
- Keep the tutorial repo open as a runnable reference for Datafeed and streaming patterns.
- During integration, run the chart in debug mode and log Datafeed lifecycle events to trace getBars and subscribe/unsubscribe calls.
- Maintain a local copy of the exact Charting Library release used by examples to avoid API mismatches.

Debugging and common pitfalls
- Missing bars or gaps: check timezone, resolution mapping, and bar-end timestamps returned by getBars.
- No live updates: verify subscribeBars is called with the same symbol/resolution used by resolveSymbol and that your stream forwards tick aggregation correctly.
- Version mismatch: ensure example code and Charting Library version align; overwrite or symlink frontend/public/charting_library in examples during local testing.

Action items for you
- Verify the Charting Library directory at frontend/public/charting_library and list top-level files to confirm the release.
- Clone the tutorial repo https://github.com/tradingview/charting-library-tutorial and the examples repo https://github.com/tradingview/charting-library-examples for runnable references.
- Use your MCP web-search server to search the provided documentation pages, follow internal links for deeper examples, and copy the Datafeed and Broker patterns you need.
- Implement a minimal IDatafeedChart wrapper returning SymbolInfo and historical bars, then add subscribeBars to forward live ticks into the chart.
- Add a debug overlay or console logger for Datafeed calls and Broker events to speed troubleshooting.

Helpful reference priorities
- Start with Getting started to confirm hosting and embedding steps: https://www.tradingview.com/charting-library-docs/latest/getting_started/
- Use Tutorials to implement Datafeed and Broker features step-by-step: https://www.tradingview.com/charting-library-docs/latest/tutorials/
- Consult the API reference for exact interfaces and TypeScript definitions: https://www.tradingview.com/charting-library-docs/latest/api/
- Use the tutorial code repo for complete example implementations: https://github.com/tradingview/charting-library-tutorial
- Use the examples repo to bootstrap framework-specific integrations: https://github.com/tradingview/charting-library-examples

Notes
- Bold labels above highlight key steps and files to check.
- Use your MCP web-search server to locate any additional pages inside the TradingView docs or GitHub repos, and follow internal links in those pages to find code snippets, changelogs, and versioned artifacts as needed.


Enable trading features for TradingView Charting Library:
Explore these library docs and feel free to follow links for more details:
https://www.tradingview.com/charting-library-docs/latest/trading_terminal/trading-concepts/
https://www.tradingview.com/charting-library-docs/latest/api/interfaces/Charting_Library.IBrokerTerminal/
Explore these broker terminal implementations examples:
https://github.com/FarmaanElahi/terminal-web/blob/main/components/chart/terminal/broker_terminal.ts
https://github.com/TargetHit/tradingview-binance/blob/master/broker-sample/src/broker.ts
