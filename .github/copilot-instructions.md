Purpose
This file contains step-by-step instructions and examples to bootstrap a small FastAPI API server with a single healthcheck endpoint using Test Driven Development. It covers project layout, virtual environment isolation, dev dependencies, TDD workflow with pytest, OpenAPI client and docs generation, git initialization, and a GitHub Actions workflow that runs tests on push.

Quick overview
- Build with FastAPI and Uvicorn.
- Use TDD: write pytest tests first, implement the feature, run tests.
- Isolate environment with either Python venv + pip or Poetry.
- Autogenerate client from OpenAPI spec and host autogenerated docs.
- CI runs pytest and linters on push using GitHub Actions.
- Enforce code quality with pre-commit hooks and standard formatters.

Recommended project layout
my-api/
├─ .github/
│  └─ workflows/
│     └─ ci.yml
├─ src/
│  └─ my_api/
│     ├─ __init__.py
│     ├─ main.py
│     └─ api/
│        └─ health.py
├─ tests/
│  └─ test_health.py
├─ pyproject.toml or requirements-dev.txt
├─ setup.cfg or tox.ini (optional)
├─ .gitignore
└─ README.md



Environment isolation and dependency management
Choose one of two approaches.
Option A Use Python venv and pip
- Create project directory and venv:
python -m venv .venv
source .venv/bin/activate
- Upgrade pip and install dev deps:
pip install --upgrade pip setuptools wheel
pip install fastapi uvicorn pytest pytest-asyncio httpx "openapi-python-client" black isort flake8 mypy pre-commit
- Freeze pinned dev dependencies for reproducibility:
pip freeze > requirements-dev.txt


Option B Use Poetry (recommended for reproducible installs)
- Install Poetry and initialize:
curl -sSL https://install.python-poetry.org | python -
poetry new my-api --src
cd my-api
poetry env use python
poetry add fastapi uvicorn
poetry add --dev pytest pytest-asyncio httpx openapi-python-client black isort flake8 mypy pre-commit
- Use poetry run to execute commands inside the virtualenv:
poetry run pytest



Dev dependencies and best practices
- Formatters: black, isort
- Linters and type checking: flake8, mypy
- Tests: pytest, pytest-asyncio, httpx (async test client)
- Client generator: openapi-python-client or openapi-generator-cli
- Pre-commit hooks: configure pre-commit to run black/isort/flake8/mypy on commit
- Keep dev dependencies separate from runtime dependencies in pyproject or requirements-dev.txt
- Pin versions in a lock file (poetry.lock or requirements-dev.txt)

TDD workflow rules
- Write a failing test for the feature in tests/ (start with the smallest behavior).
- Run pytest and confirm the test fails.
- Implement minimal code to make the test pass.
- Run pytest until all tests pass.
- Refactor if needed while keeping tests green.
- Commit only passing code and updated tests.

Example healthcheck TDD cycle
Create test first at tests/test_health.py:
import pytest
from httpx import AsyncClient
from my_api.main import app

@pytest.mark.asyncio
async def test_healthcheck_returns_200_and_payload():
    async with AsyncClient(app=app, base_url="http://test") as ac:
        r = await ac.get("/health")
    assert r.status_code == 200
    assert r.json() == {"status": "ok"}


Run tests (they will fail because we have no implementation):
pytest -q


Implement minimal FastAPI app to satisfy the test at src/my_api/main.py:
from fastapi import FastAPI
from .api.health import router as health_router

app = FastAPI(title="My API")

app.include_router(health_router)


Create health router at src/my_api/api/health.py:
from fastapi import APIRouter
from fastapi.responses import JSONResponse

router = APIRouter()

@router.get("/health", summary="Healthcheck", tags=["health"])
async def healthcheck():
    return JSONResponse({"status": "ok"})


Run tests again:
pytest -q


All tests should pass.

OpenAPI client generation and autogenerated docs
- FastAPI exposes OpenAPI at /openapi.json and interactive docs at /docs and /redoc by default. Use those for initial inspection.
- To autogenerate a typed Python client from the OpenAPI spec use openapi-python-client:
# Fetch openapi.json into openapi.json
curl -sSL http://127.0.0.1:8000/openapi.json -o openapi.json
# Generate client
openapi-python-client generate --path openapi.json --output ./clients/my_api_client
- Alternatively use openapi-generator-cli for other languages:
openapi-generator-cli generate -i openapi.json -g python -o ./clients/my_api_client
- Add generation step to a small script or Makefile target:
gen-client:
    curl -sSL http://127.0.0.1:8000/openapi.json -o openapi.json
    openapi-python-client generate --path openapi.json --output ./clients/my_api_client



Autogenerating documentation for the project
- Use FastAPI's built-in docs for runtime API documentation on /docs and /redoc.
- For static project docs, consider MkDocs with mkdocstrings or Sphinx:
- Use mkdocs for markdown docs and publish on GitHub Pages.
- Include an automated job that builds docs from the running server's OpenAPI or the source docstrings.
- Example Makefile target to export HTML docs using Redoc CLI:
export-openapi:
    curl -sSL http://127.0.0.1:8000/openapi.json -o openapi.json

redoc-html:
    npx redoc-cli bundle openapi.json -o docs/openapi.html



Git initialization and repository hygiene
- Initialize git, add .gitignore, and make first commit:
git init
echo ".venv/" > .gitignore
echo "__pycache__/" >> .gitignore
echo ".pytest_cache/" >> .gitignore
echo "clients/" >> .gitignore
git add .
git commit -m "chore: initial project layout and tests"
- Keep generated clients and virtualenv out of repo; commit generator config (openapi.json or generator config) instead if desired.

Pre-commit configuration (example)
Create .pre-commit-config.yaml:
repos:
- repo: https


Copilot instructions for working with TradingView Charting Library

Overview
- Purpose: Help a developer quickly run, integrate, extend, and debug the TradingView Charting Library located at frontend/public/charting_library in the project.
- Primary resources: official docs, tutorials, tutorial code, and examples — links provided below. Use your MCP web-search server to locate additional pages, follow internal links, and retrieve sample code as needed.

Direct links to use
- TradingView GitHub organization: https://github.com/tradingview
- Charting Library Tutorials: https://www.tradingview.com/charting-library-docs/latest/tutorials/
- Charting Library tutorial code repo: https://github.com/tradingview/charting-library-tutorial
- Charting Library examples repo: https://github.com/tradingview/charting-library-examples
- Getting started documentation: https://www.tradingview.com/charting-library-docs/latest/getting_started/
- Full API reference: https://www.tradingview.com/charting-library-docs/latest/api/

Quick start checklist
- Confirm files
- Verify the Charting Library files exist at frontend/public/charting_library and that the release matches the examples you plan to use.
- Run a tutorial/example locally
- Clone the tutorial or examples repo, align its charting_library path with frontend/public/charting_library, then serve static files (for example using a simple static server) and open the demo index.
- Implement a minimal Datafeed
- Implement required Datafeed methods: searchSymbols, resolveSymbol, getBars, subscribeBars, unsubscribeBars. Use the tutorial repo as a working reference.
- Verify SymbolInfo and time settings
- Ensure SymbolInfo shapes, timezone settings, and resolutions match your data source to avoid missing bars or misaligned timestamps.
- Add streaming and subscription logic
- Wire streaming ticks into subscribeBars; handle resubscriptions and edge cases such as session boundaries and market holidays.
- Integrate Broker features only if needed
- If using trading features, follow Broker module patterns in tutorials for order creation, account flow, and host callbacks.

Recommended dev workflow
- Use the matching example from charting-library-examples for your framework (React, Vue, Next.js, Svelte, plain HTML, etc.) and adapt container and lifecycle handling.
- Keep the tutorial repo open as a runnable reference for Datafeed and streaming patterns.
- During integration, run the chart in debug mode and log Datafeed lifecycle events to trace getBars and subscribe/unsubscribe calls.
- Maintain a local copy of the exact Charting Library release used by examples to avoid API mismatches.

Debugging and common pitfalls
- Missing bars or gaps: check timezone, resolution mapping, and bar-end timestamps returned by getBars.
- No live updates: verify subscribeBars is called with the same symbol/resolution used by resolveSymbol and that your stream forwards tick aggregation correctly.
- Version mismatch: ensure example code and Charting Library version align; overwrite or symlink frontend/public/charting_library in examples during local testing.

Action items for you
- Verify the Charting Library directory at frontend/public/charting_library and list top-level files to confirm the release.
- Clone the tutorial repo https://github.com/tradingview/charting-library-tutorial and the examples repo https://github.com/tradingview/charting-library-examples for runnable references.
- Use your MCP web-search server to search the provided documentation pages, follow internal links for deeper examples, and copy the Datafeed and Broker patterns you need.
- Implement a minimal IDatafeedChart wrapper returning SymbolInfo and historical bars, then add subscribeBars to forward live ticks into the chart.
- Add a debug overlay or console logger for Datafeed calls and Broker events to speed troubleshooting.

Helpful reference priorities
- Start with Getting started to confirm hosting and embedding steps: https://www.tradingview.com/charting-library-docs/latest/getting_started/
- Use Tutorials to implement Datafeed and Broker features step-by-step: https://www.tradingview.com/charting-library-docs/latest/tutorials/
- Consult the API reference for exact interfaces and TypeScript definitions: https://www.tradingview.com/charting-library-docs/latest/api/
- Use the tutorial code repo for complete example implementations: https://github.com/tradingview/charting-library-tutorial
- Use the examples repo to bootstrap framework-specific integrations: https://github.com/tradingview/charting-library-examples

Notes
- Bold labels above highlight key steps and files to check.
- Use your MCP web-search server to locate any additional pages inside the TradingView docs or GitHub repos, and follow internal links in those pages to find code snippets, changelogs, and versioned artifacts as needed.
