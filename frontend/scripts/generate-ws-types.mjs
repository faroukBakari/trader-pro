#!/usr/bin/env node
/**
 * WebSocket Type Generator
 *
 * Generates TypeScript types from AsyncAPI specification.
 * Converts JSON Schema definitions to TypeScript interfaces.
 *
 * Usage:
 *   node generate-ws-types.mjs <asyncapi-spec.json> <output-dir>
 */

import fs from 'fs'
import path from 'path'

// Colors for console output
const colors = {
  reset: '\x1b[0m',
  blue: '\x1b[34m',
  green: '\x1b[32m',
  yellow: '\x1b[33m',
  red: '\x1b[31m',
}

function log(color, message) {
  console.log(`${colors[color]}${message}${colors.reset}`)
}

/**
 * Convert JSON Schema type to TypeScript type
 */
function jsonSchemaTypeToTS(schema) {
  if (!schema) return 'any'

  // Handle anyOf (union types)
  if (schema.anyOf) {
    const types = schema.anyOf.map((s) => jsonSchemaTypeToTS(s))
    return types.join(' | ')
  }

  // Handle const values (literal types)
  if (schema.const !== undefined) {
    return typeof schema.const === 'string' ? `'${schema.const}'` : String(schema.const)
  }

  // Handle enum values
  if (schema.enum) {
    return schema.enum.map((v) => (typeof v === 'string' ? `'${v}'` : String(v))).join(' | ')
  }

  // Handle $ref (reference to another schema)
  if (schema.$ref) {
    const refName = schema.$ref.split('/').pop()
    return sanitizeName(refName)
  }

  // Handle array types
  if (schema.type === 'array' && schema.items) {
    const itemType = jsonSchemaTypeToTS(schema.items)
    return `Array<${itemType}>`
  }

  // Handle object types
  if (schema.type === 'object') {
    if (schema.properties) {
      return 'object'
    }
    return 'Record<string, any>'
  }

  // Handle null
  if (schema.type === 'null') {
    return 'null'
  }

  // Basic type mapping
  const typeMap = {
    string: 'string',
    number: 'number',
    integer: 'number',
    boolean: 'boolean',
    object: 'Record<string, any>',
  }

  return typeMap[schema.type] || 'any'
}

/**
 * Sanitize name to be valid TypeScript identifier
 */
function sanitizeName(name) {
  // Skip internal message wrapper schemas
  if (name.startsWith('_MsgWithPayload') || name.includes('external_packages')) {
    return null
  }

  // Clean up name
  return name
    .replace(/^_/, '')
    .replace(/_+/g, '')
    .replace(/[^a-zA-Z0-9]/g, '')
}

/**
 * Generate TypeScript interface from JSON Schema
 */
function generateInterface(name, schema) {
  const interfaceName = sanitizeName(name)

  if (!interfaceName) {
    return ''
  }

  const properties = schema.properties || {}
  const required = new Set(schema.required || [])
  const description = schema.description

  let output = ''

  if (description) {
    output += `/**\n * ${description}\n */\n`
  }

  output += `export interface ${interfaceName} {\n`

  for (const [propName, propSchema] of Object.entries(properties)) {
    const isRequired = required.has(propName)
    const propType = jsonSchemaTypeToTS(propSchema)
    const propDescription = propSchema.description

    if (propDescription) {
      output += `  /** ${propDescription} */\n`
    }

    output += `  ${propName}${isRequired ? '' : '?'}: ${propType}\n`
  }

  output += '}\n\n'

  return output
}

/**
 * Main generation function
 */
function generateTypes(specPath, outputDir) {
  try {
    log('blue', 'üìñ Reading AsyncAPI specification...')
    const spec = JSON.parse(fs.readFileSync(specPath, 'utf-8'))

    const schemas = spec.components?.schemas || {}
    const schemaCount = Object.keys(schemas).length
    log('green', `‚úÖ Found ${schemaCount} schemas in specification`)

    // Generate header
    let output = `/**
 * Auto-generated TypeScript types from AsyncAPI specification
 *
 * DO NOT EDIT MANUALLY - This file is automatically generated
 *
 * Generated from: ${spec.info?.title || 'AsyncAPI Specification'}
 * Version: ${spec.info?.version || 'unknown'}
 * AsyncAPI: ${spec.asyncapi || 'unknown'}
 *
 * Generated on: ${new Date().toISOString()}
 */

`

    // First, generate enum types
    log('blue', 'üîß Generating TypeScript enums...')
    let enumCount = 0

    for (const [name, schema] of Object.entries(schemas)) {
      // Check if this is an enum (has enum property but not properties)
      if (schema.enum && !schema.properties) {
        const enumName = sanitizeName(name)
        if (!enumName) continue

        const description = schema.description
        if (description) {
          output += `/**\n * ${description}\n */\n`
        }

        output += `export enum ${enumName} {\n`

        // For integer enums, generate based on the enum values
        if (schema.type === 'integer' || schema.type === 'number') {
          // Create enum member names from the description or use VALUE_<n> pattern
          schema.enum.forEach((value) => {
            // Try to infer name from common patterns
            let memberName = `VALUE_${value}`.replace('-', 'NEG_')

            // Special handling for common broker enums
            if (enumName === 'Side') {
              memberName = value === 1 ? 'BUY' : 'SELL'
            } else if (enumName === 'OrderStatus') {
              const statusNames = [
                'CANCELED',
                'FILLED',
                'INACTIVE',
                'PLACING',
                'REJECTED',
                'WORKING',
              ]
              memberName = statusNames[value - 1] || `STATUS_${value}`
            } else if (enumName === 'OrderType') {
              const typeNames = ['LIMIT', 'MARKET', 'STOP', 'STOP_LIMIT']
              memberName = typeNames[value - 1] || `TYPE_${value}`
            } else if (enumName === 'StopType') {
              const stopNames = ['STOP_LOSS', 'TRAILING_STOP', 'GUARANTEED_STOP']
              memberName = stopNames[value] || `STOP_${value}`
            }

            output += `  ${memberName} = ${value},\n`
          })
        } else {
          // For string enums
          schema.enum.forEach((value) => {
            const memberName = value
              .toString()
              .toUpperCase()
              .replace(/[^A-Z0-9]/g, '_')
            output += `  ${memberName} = '${value}',\n`
          })
        }

        output += '}\n\n'
        enumCount++
      }
    }

    log('green', `‚úÖ Generated ${enumCount} enums`)

    // Generate interfaces from schemas
    log('blue', 'üîß Generating TypeScript interfaces...')
    let interfaceCount = 0

    for (const [name, schema] of Object.entries(schemas)) {
      if (schema.type === 'object' && schema.properties) {
        const interfaceCode = generateInterface(name, schema)
        if (interfaceCode) {
          output += interfaceCode
          interfaceCount++
        }
      }
    }

    log('green', `‚úÖ Generated ${interfaceCount} interfaces`)

    // Clean up and create output directory
    if (fs.existsSync(outputDir)) {
      log('blue', `üßπ Cleaning existing directory: ${outputDir}`)
      fs.rmSync(outputDir, { recursive: true, force: true })
    }
    fs.mkdirSync(outputDir, { recursive: true })

    // Write to file
    const outputPath = path.join(outputDir, 'index.ts')
    fs.writeFileSync(outputPath, output)

    log('green', `\nüéâ Success! Generated types at: ${outputPath}`)
    log('blue', `üìÅ Output directory: ${outputDir}`)

    return true
  } catch (error) {
    log('red', `‚ùå Error generating types: ${error.message}`)
    console.error(error)
    return false
  }
}

// Main execution
const args = process.argv.slice(2)

if (args.length < 2) {
  console.log('Usage: node generate-ws-types.mjs <asyncapi-spec.json> <output-dir>')
  process.exit(1)
}

const [specPath, outputDir] = args

if (!fs.existsSync(specPath)) {
  log('red', `‚ùå AsyncAPI spec file not found: ${specPath}`)
  process.exit(1)
}

const success = generateTypes(specPath, outputDir)
process.exit(success ? 0 : 1)

module.exports = { generateTypes }
